@implements IMenuParent
@implements IMenuItemBasic
@inject IJSRuntime JSRuntime;

<div class="menubox @HiddenClass" style="@BoxStyle" @onclick:preventDefault @onclick:stopPropagation="true" @ref="ElementBox" @onclick="()=>{}">
	@foreach (var item in ChildMenus)
	{
		switch (item)
		{
			case IMenuItemBasic basic:
				@GetMenuItem(basic)
				;
				break;
			case MenuSeparater:
				<hr />
				break;
		}
	}
</div>

<CascadingValue Value="this">
	@ChildContent
</CascadingValue>

@code {
	public ElementReference? ElementBox { get; private set; }

	[CascadingParameter]
	public IMenuParent? Parent { get; private set; }

	[Parameter]
	public RenderFragment? ChildContent { get; set; }

	[Parameter]
	public string Title { get; set; } = string.Empty;

	public int ZIndex => (Parent?.ZIndex ?? 256) + 1;

	System.Collections.ObjectModel.ObservableCollection<IMenuItem> ChildMenus { get; } = new();

	public bool IsChildrenVisible { get; set; }

	string HiddenClass => IsChildrenVisible ? "" : "hidden";

	//string GridRowCss => string.Join(' ', ChildMenus.Select(_ => "auto"));

	string BoxStyle { get; set; } = string.Empty;

	public void AddItem(IMenuItem menuItem)
	{
		ChildMenus.Add(menuItem);
		StateHasChanged();
	}

	public bool HasChild => ChildMenus.Any();

	protected override void OnInitialized()
	{
		if (Parent is null) throw new ArgumentNullException(nameof(Parent), "MenuItem requires the parent.");
		Parent.AddItem(this);
		base.OnInitialized();
	}

	RenderFragment? _Icon;
	[Parameter]
	public RenderFragment? Icon
	{
		get => _Icon; set
		{
			_IconMaterialSymbols = null;
			_Icon = value;

		}
	}
	string? _IconMaterialSymbols;
	[Parameter]
	public string? IconMaterialSymbols
	{
		get => _IconMaterialSymbols;
		set
		{
			_IconMaterialSymbols = value;
			if (value is not null) _Icon = TabControl.GetMaterialSymbolOutlined(value);
		}
	}

	public async Task InvokeAsync()
	{
		if (HasChild)
		{
			await ShowAsync();
			return;
		}
		IMenuParent parent = this;
		while ((parent as IMenuItem)?.Parent is { } p) parent = p;
		parent.Hide();
		StateHasChanged();

		await OnHeaderSelected.InvokeAsync(null);
		StateHasChanged();
	}

	public async Task ShowAsync()
	{
		if (HasChild) IsChildrenVisible = true;
		StateHasChanged();
		var s1 = await InterOp.Functions.GetWindowSize(JSRuntime);
		var r1 = await InterOp.Functions.GetElementRect(JSRuntime, Parent?.ElementBox);
		var r2 = await InterOp.Functions.GetElementRect(JSRuntime, ElementHeader);
		var r3 = await InterOp.Functions.GetElementRect(JSRuntime, ElementBox);
		double x = 0;
		double y = 0;

		switch (Parent?.ChildPosition)
		{
			case MenuPosition.Bottom:
				x = r2?.X ?? 0;
				y = (r1?.Y + r1?.Height - 1) ?? 0;
				break;
			case MenuPosition.Right:
				x = (r1?.X + r1?.Width - 1) ?? 0;
				y = (r2?.Y - 5) ?? 0;//margin: 4px + 1px;
				break;
		}
		x = Math.Max(0, Math.Min(x, s1.Width - r3?.Width ?? 0));
		y = Math.Max(0, Math.Min(y, s1.Height - r3?.Height ?? 0));

		BoxStyle = $""""
	top: {y}px;
	left: {x}px;
	z-index: {this.ZIndex};
	"""";
		StateHasChanged();
	}

	public void Hide()
	{
		IsChildrenVisible = false;
		foreach (var item in ChildMenus)
		{
			item.Hide();
		}
	}

	public ElementReference? ElementHeader { get; set; }

	public MenuPosition ChildPosition => MenuPosition.Right;

	public async Task MouseOverItem(IMenuItem item)
	{
		if (item.IsChildrenVisible) return;
		if (!item.HasChild) return;
		foreach (var item2 in ChildMenus)
		{
			item2.Hide();
		}
		if(item is IMenuItemBasic basic) await basic.ShowAsync();
		StateHasChanged();
	}

	[Parameter]
	public EventCallback OnHeaderSelected { get; set; }

	public void NotifyStateHasChanged() => StateHasChanged();

	async Task KeyDown(KeyboardEventArgs keyboard, IMenuItemBasic basic)
	{
		switch (keyboard.Key)
		{
			case "Right" when basic.HasChild:
				await MouseOverItem(basic);
				break;
			case "Enter":
				await basic.InvokeAsync();
				break;
		}
	}

	public RenderFragment GetMenuItem(IMenuItemBasic item)
	{
		return 
	@<div class="mebubox_entry" @ref="@item.ElementHeader" @onmouseover="async ()=>{await MouseOverItem(item);}" @onclick="async ()=>{await item.InvokeAsync();}" tabindex="0" @onkeydown="async e =>await KeyDown(e,item)">
			<div class="mebubox_entry_icon">@(item.Icon)</div>
			<div class="mebubox_entry_text">@(item.Title)</div>
			@if (item.HasChild)
			{
				<div class="mebubox_entry_arrow">
					<span class="material-symbols-outlined">
						arrow_right
					</span>
				</div>
			}
		</div>;
	}
}
