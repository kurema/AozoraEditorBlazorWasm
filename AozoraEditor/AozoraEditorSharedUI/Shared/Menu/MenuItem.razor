@implements IMenuParent
@implements IMenuItemSingleBasic
@inject IJSRuntime JSRuntime;

<div class="menubox @(IsChildrenVisible ? string.Empty : "hidden")" style="@BoxStyle" @onclick:preventDefault @onclick:stopPropagation="true" @ref="ElementBox" @onclick="()=>{}">
	@foreach (var item in MenuItemProvider.GetMenuItems(ChildMenus))
	{
		if (item.IsVisible?.Invoke() == false) continue;
		switch (item)
		{
			case IMenuItemSingleBasic basic:
				@GetMenuItem(basic)
				;
				break;
			case MenuSeparater:
				<hr />
				break;
		}
	}
</div>

<CascadingValue Value="this">
	@ChildContent
</CascadingValue>

@code {
	public ElementReference? ElementBox { get; private set; }

	[CascadingParameter]
	public IMenuParent? Parent { get; private set; }

	[Parameter]
	public RenderFragment? ChildContent { get; set; }

	[Parameter]
	public string Title { get; set; } = string.Empty;

	public int ZIndex => (Parent?.ZIndex ?? 256) + 1;

	System.Collections.ObjectModel.ObservableCollection<IMenuItem> ChildMenus { get; } = new();

	public bool IsChildrenVisible { get; set; }

	//string GridRowCss => string.Join(' ', ChildMenus.Select(_ => "auto"));

	string BoxStyle { get; set; } = string.Empty;

	public void AddItem(IMenuItem menuItem)
	{
		ChildMenus.Add(menuItem);
		StateHasChanged();
	}

	public bool HasChild => ChildMenus.Any();

	protected override void OnInitialized()
	{
		if (Parent is null) throw new ArgumentNullException(nameof(Parent), "MenuItem requires the parent.");
		Parent.AddItem(this);
		base.OnInitialized();
	}

	RenderFragment? _Icon;
	[Parameter]
	public RenderFragment? Icon
	{
		get => _Icon; set
		{
			_IconMaterialSymbols = null;
			_Icon = value;

		}
	}
	string? _IconMaterialSymbols;
	[Parameter]
	public string? IconMaterialSymbols
	{
		get => _IconMaterialSymbols;
		set
		{
			_IconMaterialSymbols = value;
			if (value is not null) _Icon = FullEditor.GetMaterialSymbolOutlined(value);
		}
	}

	public async Task InvokeAsync()
	{
		if (HasChild)
		{
			await ShowAsync();
			return;
		}
		IMenuParent parent = this;
		while ((parent as IMenuItemSingle)?.Parent is { } p) parent = p;
		parent.Hide();
		StateHasChanged();

		await OnHeaderSelected.InvokeAsync(null);
		StateHasChanged();
	}

	public async Task ShowAsync(double posX = -1, double posY = -1)
	{
		if (HasChild) IsChildrenVisible = true;
		StateHasChanged();
		var s1 = await InterOp.Functions.GetWindowSize(JSRuntime);
		var r1 = await InterOp.Functions.GetElementRect(JSRuntime, Parent?.ElementBox);
		var r2 = await InterOp.Functions.GetElementRect(JSRuntime, ElementHeader);
		var r3 = await InterOp.Functions.GetElementRect(JSRuntime, ElementBox);
		double x = 0;
		double y = 0;

		switch (Parent?.ChildPosition)
		{
			case MenuPosition.Bottom:
				x = r2?.X ?? r1?.X ?? 0;
				y = (r1?.Y + r1?.Height - 1) ?? 0;
				break;
			case MenuPosition.Right:
				x = (r1?.X + r1?.Width - 1) ?? 0;
				y = (r2?.Y - 5) ?? r1?.Y ?? 0;//margin: 4px + 1px;
				break;
			case MenuPosition.ClickedPositionBottomRight:
				x = Math.Max(posX, 0);
				y = Math.Max(posY, 0);
				break;
		}
		x = Math.Max(0, Math.Min(x, s1.Width - r3?.Width ?? 0));
		y = Math.Max(0, Math.Min(y, s1.Height - r3?.Height ?? 0));

		BoxStyle = $""""
	top: {y}px;
	left: {x}px;
	z-index: {this.ZIndex};
	"""";
		StateHasChanged();
	}

	public void Hide()
	{
		IsChildrenVisible = false;
		foreach (var item in ChildMenus)
		{
			(item as IMenuItemSingle)?.Hide();
		}
	}

	public ElementReference? ElementHeader { get; set; }

	public MenuPosition ChildPosition => MenuPosition.Right;

	public async Task MouseOverItem(IMenuItemSingle item)
	{
		if (item.IsChildrenVisible) return;
		if (!item.HasChild) return;
		foreach (var item2 in ChildMenus)
		{
			(item2 as IMenuItemSingle)?.Hide();
		}
		if (item is IMenuItemSingleBasic basic) await basic.ShowAsync();
		StateHasChanged();
	}

	[Parameter]
	public EventCallback OnHeaderSelected { get; set; }

	[Parameter]
	public Func<bool>? IsVisible { get; set; }

	public void NotifyStateHasChanged() => StateHasChanged();

	async Task KeyDown(KeyboardEventArgs keyboard, IMenuItemSingleBasic basic)
	{
		switch (keyboard.Key)
		{
			case "Right" when basic.HasChild:
				await MouseOverItem(basic);
				break;
			case "Enter":
				await basic.InvokeAsync();
				break;
		}
	}

	[Parameter]
	public double ClickedPositionX { get; set; }

	[Parameter]
	public double ClickedPositionY { get; set; }

	public RenderFragment GetMenuItem(IMenuItemSingleBasic item)
	{
		return
	@<div class="mebubox_entry" @ref="@item.ElementHeader" @onmouseover="async ()=>{await MouseOverItem(item);}" @onclick="async ()=>{await item.InvokeAsync();}" tabindex="0" @onkeydown="async e =>await KeyDown(e,item)">
		<div class="mebubox_entry_icon">@(item.Icon)</div>
		<div class="mebubox_entry_text">@(item.Title)</div>
		@if (item.HasChild)
		{
			<div class="mebubox_entry_arrow">
				<span class="material-symbols-outlined">
					arrow_right
				</span>
			</div>
		}
	</div>;
	}
}
