@implements IMenuParent
@implements IMenuItem
@inject IJSRuntime JSRuntime;

<div class="menubox @HiddenClass" style="@BoxStyle" @onclick:preventDefault @onclick:stopPropagation="true" @ref="ElementBox" @onclick="()=>{}">
	@foreach (var item in ChildMenus)
	{
		switch (item)
		{
			case MenuItem:
				<div class="mebubox_entry" @ref="@item.ElementHeader" @onmouseover="async ()=>{await MouseOverItem(item);}" @onclick="async ()=>{await item.InvokeAsync();}">
					<div class="mebubox_entry_icon">@item.Icon</div>
					<div class="mebubox_entry_text">@item.Title</div>
					@if (item.HasChild)
					{
						<div class="mebubox_entry_arrow">
							<span class="material-symbols-outlined">
								arrow_right
							</span>
						</div>
					}
				</div>
				break;
			case MenuSeparater:
				<hr />
				break;
		}
	}
</div>

<CascadingValue Value="this">
	@ChildContent
</CascadingValue>

<style>
	.menubox {
		display: flex;
		flex-direction: column;
		position: fixed;
		background: var(--aozora-menubar-box-background);
		border: solid 1px var(--aozora-menubar-box-border);
		z-index: 1000;
		top: 0;
		left: 0;
		padding: 4px 0;
		box-shadow: var(--aozora-menubar-button-box-shadow);
	}

		.menubox > .mebubox_entry {
			display: grid;
			grid-template-columns: 28px 1fr 24px;
			margin: 0 4px;
			cursor: pointer;
			user-select: none;
			min-height: 28px;
			align-items: center;
		}

			.menubox > .mebubox_entry:hover {
				background: var(--aozora-menubar-box-background-hover);
			}

			.menubox > .mebubox_entry > .mebubox_entry_icon {
				display: inline;
				grid-column: 1/2;
				justify-self: start;
			}

				.menubox > .mebubox_entry > .mebubox_entry_icon > * {
					vertical-align: middle;
				}

			.menubox > .mebubox_entry > .mebubox_entry_text {
				display: inline;
				grid-column: 2/3;
				font-size: 13px;
				font-family: var(--aozora-ui-fonts);
			}

			.menubox > .mebubox_entry > .mebubox_entry_arrow {
				display: inline;
				grid-column: 3/4;
			}

				.menubox > .mebubox_entry > .mebubox_entry_arrow > span {
					vertical-align: middle;
				}

		.menubox > hr {
			height: 0;
			margin: 0;
			padding: 0;
			border: 0;
			border-top: 1px solid var(--aozora-menubar-box-border);
			margin: 6px 0px;
			width: 100%;
		}
</style>

@code {
	public ElementReference? ElementBox { get; private set; }

	[CascadingParameter]
	public IMenuParent? Parent { get; private set; }

	[Parameter]
	public RenderFragment? ChildContent { get; set; }

	[Parameter]
	public string Title { get; set; } = string.Empty;

	public int ZIndex => (Parent?.ZIndex ?? 256) + 1;

	System.Collections.ObjectModel.ObservableCollection<IMenuItem> ChildMenus { get; } = new();

	public bool IsChildrenVisible { get; set; }

	string HiddenClass => IsChildrenVisible ? "" : "hidden";

	//string GridRowCss => string.Join(' ', ChildMenus.Select(_ => "auto"));

	string BoxStyle { get; set; } = string.Empty;

	public void AddItem(IMenuItem menuItem)
	{
		ChildMenus.Add(menuItem);
		StateHasChanged();
	}

	public bool HasChild => ChildMenus.Any();

	protected override void OnInitialized()
	{
		if (Parent is null) throw new ArgumentNullException(nameof(Parent), "MenuItem requires the parent.");
		Parent.AddItem(this);
		base.OnInitialized();
	}

	RenderFragment? _Icon;
	[Parameter]
	public RenderFragment? Icon
	{
		get => _Icon; set
		{
			_IconMaterialSymbols = null;
			_Icon = value;

		}
	}
	string? _IconMaterialSymbols;
	[Parameter]
	public string? IconMaterialSymbols
	{
		get => _IconMaterialSymbols;
		set
		{
			_IconMaterialSymbols = value;
			if (value is not null) _Icon = TabControl.GetMaterialSymbolOutlined(value);
		}
	}

	public async Task InvokeAsync()
	{
		if (HasChild)
		{
			await ShowAsync();
			return;
		}
		IMenuParent parent = this;
		while ((parent as IMenuItem)?.Parent is { } p) parent = p;
		parent.Hide();
		StateHasChanged();

		await OnHeaderSelected.InvokeAsync(null);
		StateHasChanged();
	}

	public async Task ShowAsync()
	{
		if (HasChild) IsChildrenVisible = true;
		StateHasChanged();
		var s1 = await InterOp.Functions.GetWindowSize(JSRuntime);
		var r1 = await InterOp.Functions.GetElementRect(JSRuntime, Parent?.ElementBox);
		var r2 = await InterOp.Functions.GetElementRect(JSRuntime, ElementHeader);
		var r3 = await InterOp.Functions.GetElementRect(JSRuntime, ElementBox);
		double x = 0;
		double y = 0;

		switch (Parent?.ChildPosition)
		{
			case MenuPosition.Bottom:
				x = r2?.X ?? 0;
				y = (r1?.Y + r1?.Height - 1) ?? 0;
				break;
			case MenuPosition.Right:
				x = (r1?.X + r1?.Width - 1) ?? 0;
				y = (r2?.Y - 5) ?? 0;//margin: 4px + 1px;
				break;
		}
		x = Math.Max(0, Math.Min(x, s1.Width - r3?.Width ?? 0));
		y = Math.Max(0, Math.Min(y, s1.Height - r3?.Height ?? 0));

		BoxStyle = $""""
	top: {y}px;
	left: {x}px;
	z-index: {this.ZIndex};
	"""";
		StateHasChanged();
	}

	public void Hide()
	{
		IsChildrenVisible = false;
		foreach (var item in ChildMenus)
		{
			item.Hide();
		}
	}

	public ElementReference? ElementHeader { get; set; }

	public MenuPosition ChildPosition => MenuPosition.Right;

	public async Task MouseOverItem(IMenuItem item)
	{
		if (item.IsChildrenVisible) return;
		foreach (var item2 in ChildMenus)
		{
			item2.Hide();
		}
		if (!item.HasChild) return;
		await item.ShowAsync();
		StateHasChanged();
	}

	[Parameter]
	public EventCallback OnHeaderSelected { get; set; }

	public void NotifyStateHasChanged() => StateHasChanged();
}
