@implements IMenuParent
@implements IMenuItemSingleBasic
@inject IJSRuntime JSRuntime;

@{
	<div class="menubox @(IsChildrenVisible ? string.Empty : "hidden")" style="@BoxStyle" @onclick:preventDefault @onclick:stopPropagation="true" @ref="ElementBox" @onclick="()=>{}">
		@foreach (var item in FlatMenuItems ?? new IMenuItemSingle[0])
		{
			if (item.IsVisible?.Invoke() == false) continue;
			switch (item)
			{
				case IMenuItemSingleBasic basic:
					@GetMenuItem(basic)
					break;
				case MenuSeparater:
					<hr />
					break;
			}
		}
	</div>
}

<CascadingValue Name="ParentProvider" Value="(IMenuParent?)null">
	<CascadingValue Name="Parent" Value="this">
		@ChildContent
	</CascadingValue>
</CascadingValue>

@code {
	public ElementReference? ElementBox { get; private set; }

	[CascadingParameter(Name = nameof(Parent))]
	public IMenuParent? Parent { get; set; }

	[CascadingParameter(Name = nameof(ParentProvider))]
	public IMenuParent? ParentProvider { get; set; }

	[Parameter]
	public RenderFragment? ChildContent { get; set; }

	[Parameter]
	public string Title { get; set; } = string.Empty;

	IMenuItemSingle[]? FlatMenuItems;

	public int ZIndex => (Parent?.ZIndex ?? 256) + 1;

	System.Collections.ObjectModel.ObservableCollection<IMenuItem> ChildMenus { get; } = new();

	public bool IsChildrenVisible { get; set; }

	string BoxStyle { get; set; } = string.Empty;

	public void AddItem(IMenuItem menuItem)
	{
		ChildMenus.Add(menuItem);
		StateHasChanged();
	}

	public bool HasChild => ChildMenus.Any();

	protected override void OnInitialized()
	{
		if (ParentProvider is not null) ParentProvider.AddItem(this);
		else if (Parent is not null) Parent.AddItem(this);
		else throw new ArgumentNullException(nameof(Parent), "MenuItem requires the parent.");
		UpdateFlatMenu();
		base.OnInitialized();
	}

	public void UpdateFlatMenu()
	{
		var flatItems = MenuItemProvider.GetFlatMenuItemsTuple(ChildMenus).ToArray();
		// foreach (var item in flatItems.Where(a => a.Provider is not null)) item.Body.Parent = this;
		FlatMenuItems = flatItems.Select(a => a.Body).ToArray();
	}

	RenderFragment? _Icon;
	[Parameter]
	public RenderFragment? Icon
	{
		get => _Icon; set
		{
			_IconMaterialSymbols = null;
			_Icon = value;

		}
	}
	string? _IconMaterialSymbols;
	[Parameter]
	public string? IconMaterialSymbols
	{
		get => _IconMaterialSymbols;
		set
		{
			_IconMaterialSymbols = value;
			if (value is not null) _Icon = FullEditor.GetMaterialSymbolOutlined(value);
		}
	}

	public async Task InvokeAsync()
	{
		if (HasChild)
		{
			await ShowAsync();
			return;
		}
		IMenuParent parent = this;
		while ((parent as IMenuItemSingle)?.Parent is { } p) parent = p;
		parent.Hide();
		StateHasChanged();

		if (OnHeaderSelected.HasDelegate) await OnHeaderSelected.InvokeAsync(null);
		StateHasChanged();
	}

	public async Task ShowAsync(double posX = -1, double posY = -1)
	{
		// foreach (var item in ChildMenus) (item as MenuItemProvider)?.UpdateMenus();
		// Console.WriteLine($"{this.Title} {this.Parent?.ToString()}");
		UpdateFlatMenu();
		if (HasChild) IsChildrenVisible = true;
		StateHasChanged();
		var s1 = await InterOp.Functions.GetWindowSize(JSRuntime);
		var r1 = await InterOp.Functions.GetElementRect(JSRuntime, Parent?.ElementBox);
		var r2 = await InterOp.Functions.GetElementRect(JSRuntime, ElementHeader);
		var r3 = await InterOp.Functions.GetElementRect(JSRuntime, ElementBox);
		double x = 0;
		double y = 0;

		switch (Parent?.ChildPosition)
		{
			case MenuPosition.Bottom:
				x = r2?.X ?? r1?.X ?? 0;
				y = (r1?.Y + r1?.Height - 1) ?? 0;
				break;
			case MenuPosition.Right:
				x = (r1?.X + r1?.Width - 1) ?? 0;
				y = (r2?.Y - 5) ?? r1?.Y ?? 0;//margin: 4px + 1px;
				break;
			case MenuPosition.ClickedPositionBottomRight:
				x = Math.Max(posX, 0);
				y = Math.Max(posY, 0);
				break;
		}
		x = Math.Max(0, Math.Min(x, s1.Width - r3?.Width ?? 0));
		y = Math.Max(0, Math.Min(y, s1.Height - r3?.Height ?? 0));

		BoxStyle = $""""
	top: {y}px;
	left: {x}px;
	z-index: {this.ZIndex};
	"""";
		// Console.WriteLine(BoxStyle);
		StateHasChanged();
	}

	public void Hide()
	{
		IsChildrenVisible = false;
		if (FlatMenuItems is null) return;
		foreach(var item in ChildMenus)
		{
			(item as IMenuParent)?.Hide();
		}
		// foreach (var item in FlatMenuItems)
		// {
		// 	item.Hide();
		// }
	}

	public ElementReference? ElementHeader { get; set; }

	public MenuPosition ChildPosition => MenuPosition.Right;

	public async Task MouseOverItem(IMenuItemSingle item)
	{
		if (item.IsChildrenVisible) return;
		if (!item.HasChild) return;
		foreach (var item2 in ChildMenus)
		{
			(item2 as IMenuParent)?.Hide();
		}
		if (item is IMenuItemSingleBasic basic) await basic.ShowAsync();
		StateHasChanged();
	}

	[Parameter]
	public EventCallback OnHeaderSelected { get; set; }

	[Parameter]
	public Func<bool>? IsVisible { get; set; }

	public void NotifyStateHasChanged() => StateHasChanged();

	async Task KeyDown(KeyboardEventArgs keyboard, IMenuItemSingleBasic basic)
	{
		switch (keyboard.Key)
		{
			case "Right" when basic.HasChild:
				await MouseOverItem(basic);
				break;
			case "Enter":
				await basic.InvokeAsync();
				break;
		}
	}

	[Parameter]
	public double ClickedPositionX { get; set; }

	[Parameter]
	public double ClickedPositionY { get; set; }

	public RenderFragment GetMenuItem(IMenuItemSingleBasic item)
	{
		return
	@<div class="mebubox_entry" @ref="@item.ElementHeader" @onmouseover="async ()=>{await MouseOverItem(item);}" @onclick="async ()=>{await item.InvokeAsync();}" tabindex="0" @onkeydown="async e =>await KeyDown(e,item)">
		<div class="mebubox_entry_icon">@(item.Icon)</div>
		<div class="mebubox_entry_text">@(item.Title)</div>
		@if (item.HasChild)
		{
			<div class="mebubox_entry_arrow">
				<span class="material-symbols-outlined">
					arrow_right
				</span>
			</div>
		}
	</div>;
	}
}
