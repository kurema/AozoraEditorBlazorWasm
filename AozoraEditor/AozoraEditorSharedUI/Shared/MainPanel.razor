@inject IJSRuntime JSRuntime;

<div class="ContainerMain">
	<div class="PanelTop">
		<button class="ButtonMini" @onclick="@ShowPreview">
			<span class="material-symbols-outlined">preview</span>
		</button>
		<div class="FileInputButton ButtonMini">
			<span class="material-symbols-outlined">file_open</span>
			<Microsoft.AspNetCore.Components.Forms.InputFile OnChange="FileUpload" />
		</div>
		<button class="ButtonMini" @onclick="@DownloadText">
			<span class="material-symbols-outlined">save</span>
		</button>

	</div>
	<div class="@ClassMain"><MonacoEditorAozora @ref="editor" /></div>
	<div class="@ClassSub"><SubPanel PreviewDocument="@PreviewHtml" /></div>
</div>

<style>
	.ContainerMain {
		display: grid;
		grid-template-rows: auto 1fr;
		grid-template-columns: 1fr 1fr;
		flex: 1 0 0;
	}

	.PanelTop {
		grid-row: 1/2;
		grid-column: 1/3;
		min-width: 0;
	}

	.PanelHalfLeft {
		grid-row: 2/3;
		grid-column: 1/2;
		min-width: 0;
	}

	.PanelHalfRight {
		grid-row: 2/3;
		grid-column: 2/3;
		min-width: 0;
	}

	.PanelFull {
		grid-row: 2/3;
		grid-column: 1/3;
		min-width: 0;
	}

	.PanelNone {
		display: none;
		min-width: 0;
	}

	.ButtonMini {
		background-color: transparent;
		-webkit-appearance: none;
		-moz-appearance: none;
		appearance: none;
		border: 0;
		border-radius: 0;
	}

		.ButtonMini:hover {
			background-color: #7F7F7F22;
		}

	.FileInputButton {
		display: inline-flex;
		align-items: center;
		justify-content: center;
		cursor: pointer;
		position: relative;
	}

		.FileInputButton input[type=file] {
			position: absolute;
			width: 100%;
			height: 100%;
			/* このやり方はちょっと良くない(コメントアウトすれば分かるが隙間は押せない)。けどほぼ問題なし。 */
			opacity: 0;
			cursor: pointer;
		}
</style>
@code {
	string ClassMain { get; set; } = "PanelFull";
	string ClassSub { get; set; } = "PanelNone";

	private MonacoEditorAozora? editor;

	DisplayModes _DisplayMode = DisplayModes.MainFull;
	public DisplayModes DisplayMode
	{
		get => _DisplayMode;
		set
		{
			if (_DisplayMode == value) return;
			switch (value)
			{
				case DisplayModes.MainFull:
					ClassMain = "PanelFull";
					ClassSub = "PanelNone";
					break;
				case DisplayModes.Separated:
					ClassMain = "PanelHalfLeft";
					ClassSub = "PanelHalfRight";
					break;
			}
			_DisplayMode = value;
		}
	}

	public void ToggleDisplayMode() => DisplayMode = DisplayMode switch
	{
		DisplayModes.MainFull => DisplayModes.Separated,
		DisplayModes.Separated => DisplayModes.MainFull,
		_ => DisplayModes.MainFull,
	};

	public string PreviewHtml { get; set; } = "<html><body>プレビューはここに表示されます。</body></html>";

	public async Task ShowPreview()
	{
		PreviewHtml = "<html><body><p>プレビュー作成中です<br />この間、UIがフリーズすることがあります。</p></body></html>";
		DisplayMode = DisplayModes.Separated;
		if (editor is null)
		{
			Console.WriteLine("Null!");
			return;
		}
		if (editor?.Content is null) return;
		var text = await editor.Content.GetValue();
		var js = new Aozora.JstreamString(text);
		var output = new Aozora.Helpers.OutputString();
		var aozora = new Aozora.Aozora2Html(js, output)
			{
				UseJisx0213Accent = true,
				UseJisx0214EmbedGaiji = true,
				UseUnicodeEmbedGaiji = true,
			}; ;
		try
		{
			aozora.Process();
			PreviewHtml = output.ToString();
		}
		catch
		{
			PreviewHtml = "<html><body><p>プレビュー作成に失敗しました。</p></body></html>";
		}
	}

	public enum DisplayModes
	{
		MainFull, Separated,
	}

	const long MaxFileSize = 256 * 1024 * 1024;//256 MB. This should be enough.

	private async Task FileUpload(Microsoft.AspNetCore.Components.Forms.InputFileChangeEventArgs e)
	{
		if (e.FileCount != 1 || e.File?.Name == null) return;
		var ext = Path.GetExtension(e.File.Name);
		try
		{
			var ms = new MemoryStream();
			await e.File.OpenReadStream(MaxFileSize).CopyToAsync(ms);
			if (ext.Equals(".zip", StringComparison.InvariantCultureIgnoreCase))
			{
				using var zip = new System.IO.Compression.ZipArchive(ms, System.IO.Compression.ZipArchiveMode.Read);
				var f = zip.Entries.FirstOrDefault(a => System.IO.Path.GetExtension(a.Name)?.Equals(".txt", StringComparison.InvariantCultureIgnoreCase) == true);
				if (f is null) goto fail;
				var s2 = f.Open();
				if (s2 is null) goto fail;
				var text = await LoadText(s2);
				if (text is null) goto fail;
				if (editor?.Content is null) goto fail;
				await editor.Content.SetValue(text);
			}
			else
			{
				var text = await LoadText(ms);
				if (text is null) goto fail;
				if (editor?.Content is null) goto fail;
				await editor.Content.SetValue(text);
			}
		}
		catch (Exception e2)
		{
			Console.WriteLine($"Loading file failed:\n{e2}");
		}
		return;
	fail:
		Console.WriteLine($"Loading file failed.");
		return;
	}

	private async Task<string?> LoadText(Stream stream)
	{
		try
		{
			var sjis = System.Text.CodePagesEncodingProvider.Instance.GetEncoding("shift-jis", new System.Text.EncoderExceptionFallback(), new System.Text.DecoderExceptionFallback());
			if (sjis is null) throw new Exception();
			using var sr = new StreamReader(stream, sjis);
			return await sr.ReadToEndAsync();
		}
		catch { }
		try
		{
			using var sr = new StreamReader(stream, true);
			return await sr.ReadToEndAsync();
		}
		catch { }
		return null;
	}

	private async Task DownloadText()
	{
		using var ms = new MemoryStream();
		if (editor?.Content is null) goto fail;
		var text = await editor.Content.GetValue();

		async Task saveMs(Stream ms)
		{
			ms.Seek(0, SeekOrigin.Begin);
			using var streamRef = new DotNetStreamReference(ms);
			await JSRuntime.InvokeVoidAsync("window.DownloadFileFromStream", "aozora.txt", streamRef);
		}

		try
		{
			var sjis = System.Text.CodePagesEncodingProvider.Instance.GetEncoding("shift-jis", new System.Text.EncoderExceptionFallback(), new System.Text.DecoderExceptionFallback());
			if (sjis is null) throw new Exception();
			var sw = new StreamWriter(ms, sjis);
			await sw.WriteAsync(text);
			await sw.FlushAsync();
			await saveMs(ms);
			sw.Close();
			//await sw.DisposeAsync();
		}
		catch (Exception e2)
		{
			Console.WriteLine(e2);
			try
			{
				var sw = new StreamWriter(ms, System.Text.Encoding.UTF8);
				await sw.WriteAsync(text);
				await sw.FlushAsync();
				await saveMs(ms);
				sw.Close();
				//await sw.DisposeAsync();
			}
			catch (Exception e)
			{
				Console.WriteLine(e);
				goto fail;
			}
		}

		return;
	fail:
		Console.WriteLine("Saving file failed.");
		return;
	}
}
